// Copyright 2024-2025 NetCracker Technology Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v7

import (
	"github.com/Netcracker/qubership-kafka/operator/api/kmm"
	"k8s.io/api/core/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Akhq) DeepCopyInto(out *Akhq) {
	*out = *in
	in.Affinity.DeepCopyInto(&out.Affinity)
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	in.Resources.DeepCopyInto(&out.Resources)
	in.SecurityContext.DeepCopyInto(&out.SecurityContext)
	if in.KafkaPollTimeout != nil {
		in, out := &in.KafkaPollTimeout, &out.KafkaPollTimeout
		*out = new(int64)
		**out = **in
	}
	if in.EnableAccessLog != nil {
		in, out := &in.EnableAccessLog, &out.EnableAccessLog
		*out = new(bool)
		**out = **in
	}
	if in.CustomLabels != nil {
		in, out := &in.CustomLabels, &out.CustomLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.EnvironmentVariables != nil {
		in, out := &in.EnvironmentVariables, &out.EnvironmentVariables
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.HeapSize != nil {
		in, out := &in.HeapSize, &out.HeapSize
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Akhq.
func (in *Akhq) DeepCopy() *Akhq {
	if in == nil {
		return nil
	}
	out := new(Akhq)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AkhqStatus) DeepCopyInto(out *AkhqStatus) {
	*out = *in
	if in.Nodes != nil {
		in, out := &in.Nodes, &out.Nodes
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AkhqStatus.
func (in *AkhqStatus) DeepCopy() *AkhqStatus {
	if in == nil {
		return nil
	}
	out := new(AkhqStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupDaemon) DeepCopyInto(out *BackupDaemon) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupDaemon.
func (in *BackupDaemon) DeepCopy() *BackupDaemon {
	if in == nil {
		return nil
	}
	out := new(BackupDaemon)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Cluster) DeepCopyInto(out *Cluster) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Cluster.
func (in *Cluster) DeepCopy() *Cluster {
	if in == nil {
		return nil
	}
	out := new(Cluster)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DisasterRecovery) DeepCopyInto(out *DisasterRecovery) {
	*out = *in
	out.MirrorMakerReplication = in.MirrorMakerReplication
	out.TopicsBackup = in.TopicsBackup
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DisasterRecovery.
func (in *DisasterRecovery) DeepCopy() *DisasterRecovery {
	if in == nil {
		return nil
	}
	out := new(DisasterRecovery)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DisasterRecoveryStatus) DeepCopyInto(out *DisasterRecoveryStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DisasterRecoveryStatus.
func (in *DisasterRecoveryStatus) DeepCopy() *DisasterRecoveryStatus {
	if in == nil {
		return nil
	}
	out := new(DisasterRecoveryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Global) DeepCopyInto(out *Global) {
	*out = *in
	if in.CustomLabels != nil {
		in, out := &in.CustomLabels, &out.CustomLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.DefaultLabels != nil {
		in, out := &in.DefaultLabels, &out.DefaultLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	out.KafkaSsl = in.KafkaSsl
	out.Kraft = in.Kraft
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Global.
func (in *Global) DeepCopy() *Global {
	if in == nil {
		return nil
	}
	out := new(Global)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IntegrationTests) DeepCopyInto(out *IntegrationTests) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IntegrationTests.
func (in *IntegrationTests) DeepCopy() *IntegrationTests {
	if in == nil {
		return nil
	}
	out := new(IntegrationTests)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafka) DeepCopyInto(out *Kafka) {
	*out = *in
	in.Affinity.DeepCopyInto(&out.Affinity)
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DisableSecurity != nil {
		in, out := &in.DisableSecurity, &out.DisableSecurity
		*out = new(bool)
		**out = **in
	}
	in.Oauth.DeepCopyInto(&out.Oauth)
	in.Ssl.DeepCopyInto(&out.Ssl)
	in.Scaling.DeepCopyInto(&out.Scaling)
	in.Resources.DeepCopyInto(&out.Resources)
	in.SecurityContext.DeepCopyInto(&out.SecurityContext)
	in.Storage.DeepCopyInto(&out.Storage)
	if in.GetRacksFromNodeLabels != nil {
		in, out := &in.GetRacksFromNodeLabels, &out.GetRacksFromNodeLabels
		*out = new(bool)
		**out = **in
	}
	if in.Racks != nil {
		in, out := &in.Racks, &out.Racks
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.TerminationGracePeriod != nil {
		in, out := &in.TerminationGracePeriod, &out.TerminationGracePeriod
		*out = new(int64)
		**out = **in
	}
	if in.ZookeeperSetACL != nil {
		in, out := &in.ZookeeperSetACL, &out.ZookeeperSetACL
		*out = new(bool)
		**out = **in
	}
	if in.ExternalHostNames != nil {
		in, out := &in.ExternalHostNames, &out.ExternalHostNames
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ExternalPorts != nil {
		in, out := &in.ExternalPorts, &out.ExternalPorts
		*out = make([]int, len(*in))
		copy(*out, *in)
	}
	if in.EnvironmentVariables != nil {
		in, out := &in.EnvironmentVariables, &out.EnvironmentVariables
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.RollbackTimeout != nil {
		in, out := &in.RollbackTimeout, &out.RollbackTimeout
		*out = new(int32)
		**out = **in
	}
	if in.HealthCheckTimeout != nil {
		in, out := &in.HealthCheckTimeout, &out.HealthCheckTimeout
		*out = new(int32)
		**out = **in
	}
	if in.EnableAuditLogs != nil {
		in, out := &in.EnableAuditLogs, &out.EnableAuditLogs
		*out = new(bool)
		**out = **in
	}
	if in.EnableAuthorization != nil {
		in, out := &in.EnableAuthorization, &out.EnableAuthorization
		*out = new(bool)
		**out = **in
	}
	if in.KafkaDiscoveryMeta != nil {
		in, out := &in.KafkaDiscoveryMeta, &out.KafkaDiscoveryMeta
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.KafkaDiscoveryTags != nil {
		in, out := &in.KafkaDiscoveryTags, &out.KafkaDiscoveryTags
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.CustomLabels != nil {
		in, out := &in.CustomLabels, &out.CustomLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafka.
func (in *Kafka) DeepCopy() *Kafka {
	if in == nil {
		return nil
	}
	out := new(Kafka)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaService) DeepCopyInto(out *KafkaService) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaService.
func (in *KafkaService) DeepCopy() *KafkaService {
	if in == nil {
		return nil
	}
	out := new(KafkaService)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaService) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaServiceList) DeepCopyInto(out *KafkaServiceList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaService, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaServiceList.
func (in *KafkaServiceList) DeepCopy() *KafkaServiceList {
	if in == nil {
		return nil
	}
	out := new(KafkaServiceList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaServiceList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaServiceSpec) DeepCopyInto(out *KafkaServiceSpec) {
	*out = *in
	if in.Global != nil {
		in, out := &in.Global, &out.Global
		*out = new(Global)
		(*in).DeepCopyInto(*out)
	}
	if in.DisasterRecovery != nil {
		in, out := &in.DisasterRecovery, &out.DisasterRecovery
		*out = new(DisasterRecovery)
		**out = **in
	}
	if in.Kafka != nil {
		in, out := &in.Kafka, &out.Kafka
		*out = new(Kafka)
		(*in).DeepCopyInto(*out)
	}
	if in.Akhq != nil {
		in, out := &in.Akhq, &out.Akhq
		*out = new(Akhq)
		(*in).DeepCopyInto(*out)
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = new(Monitoring)
		(*in).DeepCopyInto(*out)
	}
	if in.MirrorMaker != nil {
		in, out := &in.MirrorMaker, &out.MirrorMaker
		*out = new(MirrorMaker)
		(*in).DeepCopyInto(*out)
	}
	if in.MirrorMakerMonitoring != nil {
		in, out := &in.MirrorMakerMonitoring, &out.MirrorMakerMonitoring
		*out = new(MirrorMakerMonitoring)
		(*in).DeepCopyInto(*out)
	}
	if in.VaultSecretManagement != nil {
		in, out := &in.VaultSecretManagement, &out.VaultSecretManagement
		*out = new(VaultSecretManagement)
		(*in).DeepCopyInto(*out)
	}
	if in.IntegrationTests != nil {
		in, out := &in.IntegrationTests, &out.IntegrationTests
		*out = new(IntegrationTests)
		**out = **in
	}
	if in.BackupDaemon != nil {
		in, out := &in.BackupDaemon, &out.BackupDaemon
		*out = new(BackupDaemon)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaServiceSpec.
func (in *KafkaServiceSpec) DeepCopy() *KafkaServiceSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaServiceSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaServiceStatus) DeepCopyInto(out *KafkaServiceStatus) {
	*out = *in
	in.KafkaStatus.DeepCopyInto(&out.KafkaStatus)
	out.PartitionsReassignmentStatus = in.PartitionsReassignmentStatus
	in.AkhqStatus.DeepCopyInto(&out.AkhqStatus)
	in.MonitoringStatus.DeepCopyInto(&out.MonitoringStatus)
	in.MirrorMakerStatus.DeepCopyInto(&out.MirrorMakerStatus)
	in.VaultSecretManagementStatus.DeepCopyInto(&out.VaultSecretManagementStatus)
	out.DisasterRecoveryStatus = in.DisasterRecoveryStatus
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]StatusCondition, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaServiceStatus.
func (in *KafkaServiceStatus) DeepCopy() *KafkaServiceStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaServiceStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSsl) DeepCopyInto(out *KafkaSsl) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSsl.
func (in *KafkaSsl) DeepCopy() *KafkaSsl {
	if in == nil {
		return nil
	}
	out := new(KafkaSsl)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaStatus) DeepCopyInto(out *KafkaStatus) {
	*out = *in
	if in.Brokers != nil {
		in, out := &in.Brokers, &out.Brokers
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaStatus.
func (in *KafkaStatus) DeepCopy() *KafkaStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kraft) DeepCopyInto(out *Kraft) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kraft.
func (in *Kraft) DeepCopy() *Kraft {
	if in == nil {
		return nil
	}
	out := new(Kraft)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LagExporter) DeepCopyInto(out *LagExporter) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LagExporter.
func (in *LagExporter) DeepCopy() *LagExporter {
	if in == nil {
		return nil
	}
	out := new(LagExporter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MirrorMaker) DeepCopyInto(out *MirrorMaker) {
	*out = *in
	in.Affinity.DeepCopyInto(&out.Affinity)
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	in.Resources.DeepCopyInto(&out.Resources)
	if in.Clusters != nil {
		in, out := &in.Clusters, &out.Clusters
		*out = make([]Cluster, len(*in))
		copy(*out, *in)
	}
	if in.RefreshTopicsIntervalSeconds != nil {
		in, out := &in.RefreshTopicsIntervalSeconds, &out.RefreshTopicsIntervalSeconds
		*out = new(int32)
		**out = **in
	}
	if in.RefreshGroupsIntervalSeconds != nil {
		in, out := &in.RefreshGroupsIntervalSeconds, &out.RefreshGroupsIntervalSeconds
		*out = new(int32)
		**out = **in
	}
	in.SecurityContext.DeepCopyInto(&out.SecurityContext)
	if in.EnvironmentVariables != nil {
		in, out := &in.EnvironmentVariables, &out.EnvironmentVariables
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.RepeatedReplication != nil {
		in, out := &in.RepeatedReplication, &out.RepeatedReplication
		*out = new(bool)
		**out = **in
	}
	if in.CustomLabels != nil {
		in, out := &in.CustomLabels, &out.CustomLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Transformation != nil {
		in, out := &in.Transformation, &out.Transformation
		*out = new(kmm.Transformation)
		(*in).DeepCopyInto(*out)
	}
	if in.TasksMax != nil {
		in, out := &in.TasksMax, &out.TasksMax
		*out = new(int32)
		**out = **in
	}
	if in.InternalRestEnabled != nil {
		in, out := &in.InternalRestEnabled, &out.InternalRestEnabled
		*out = new(bool)
		**out = **in
	}
	if in.JolokiaPort != nil {
		in, out := &in.JolokiaPort, &out.JolokiaPort
		*out = new(int32)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MirrorMaker.
func (in *MirrorMaker) DeepCopy() *MirrorMaker {
	if in == nil {
		return nil
	}
	out := new(MirrorMaker)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MirrorMakerMonitoring) DeepCopyInto(out *MirrorMakerMonitoring) {
	*out = *in
	in.Affinity.DeepCopyInto(&out.Affinity)
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	in.Resources.DeepCopyInto(&out.Resources)
	in.SecurityContext.DeepCopyInto(&out.SecurityContext)
	if in.CustomLabels != nil {
		in, out := &in.CustomLabels, &out.CustomLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.JolokiaUrls != nil {
		in, out := &in.JolokiaUrls, &out.JolokiaUrls
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MirrorMakerMonitoring.
func (in *MirrorMakerMonitoring) DeepCopy() *MirrorMakerMonitoring {
	if in == nil {
		return nil
	}
	out := new(MirrorMakerMonitoring)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MirrorMakerReplication) DeepCopyInto(out *MirrorMakerReplication) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MirrorMakerReplication.
func (in *MirrorMakerReplication) DeepCopy() *MirrorMakerReplication {
	if in == nil {
		return nil
	}
	out := new(MirrorMakerReplication)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MirrorMakerStatus) DeepCopyInto(out *MirrorMakerStatus) {
	*out = *in
	if in.Nodes != nil {
		in, out := &in.Nodes, &out.Nodes
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MirrorMakerStatus.
func (in *MirrorMakerStatus) DeepCopy() *MirrorMakerStatus {
	if in == nil {
		return nil
	}
	out := new(MirrorMakerStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Monitoring) DeepCopyInto(out *Monitoring) {
	*out = *in
	in.Affinity.DeepCopyInto(&out.Affinity)
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	in.Resources.DeepCopyInto(&out.Resources)
	in.SecurityContext.DeepCopyInto(&out.SecurityContext)
	if in.LagExporter != nil {
		in, out := &in.LagExporter, &out.LagExporter
		*out = new(LagExporter)
		**out = **in
	}
	if in.CustomLabels != nil {
		in, out := &in.CustomLabels, &out.CustomLabels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Monitoring.
func (in *Monitoring) DeepCopy() *Monitoring {
	if in == nil {
		return nil
	}
	out := new(Monitoring)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MonitoringStatus) DeepCopyInto(out *MonitoringStatus) {
	*out = *in
	if in.Nodes != nil {
		in, out := &in.Nodes, &out.Nodes
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MonitoringStatus.
func (in *MonitoringStatus) DeepCopy() *MonitoringStatus {
	if in == nil {
		return nil
	}
	out := new(MonitoringStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OAuth) DeepCopyInto(out *OAuth) {
	*out = *in
	if in.ClockSkew != nil {
		in, out := &in.ClockSkew, &out.ClockSkew
		*out = new(int)
		**out = **in
	}
	if in.JwkSourceType != nil {
		in, out := &in.JwkSourceType, &out.JwkSourceType
		*out = new(string)
		**out = **in
	}
	if in.JwksConnectionTimeout != nil {
		in, out := &in.JwksConnectionTimeout, &out.JwksConnectionTimeout
		*out = new(int)
		**out = **in
	}
	if in.JwksReadTimeout != nil {
		in, out := &in.JwksReadTimeout, &out.JwksReadTimeout
		*out = new(int)
		**out = **in
	}
	if in.JwksSizeLimit != nil {
		in, out := &in.JwksSizeLimit, &out.JwksSizeLimit
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OAuth.
func (in *OAuth) DeepCopy() *OAuth {
	if in == nil {
		return nil
	}
	out := new(OAuth)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PartitionsReassignmentStatus) DeepCopyInto(out *PartitionsReassignmentStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PartitionsReassignmentStatus.
func (in *PartitionsReassignmentStatus) DeepCopy() *PartitionsReassignmentStatus {
	if in == nil {
		return nil
	}
	out := new(PartitionsReassignmentStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Scaling) DeepCopyInto(out *Scaling) {
	*out = *in
	if in.ReassignPartitions != nil {
		in, out := &in.ReassignPartitions, &out.ReassignPartitions
		*out = new(bool)
		**out = **in
	}
	if in.BrokerDeploymentScaleInEnabled != nil {
		in, out := &in.BrokerDeploymentScaleInEnabled, &out.BrokerDeploymentScaleInEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AllBrokersStartTimeoutSeconds != nil {
		in, out := &in.AllBrokersStartTimeoutSeconds, &out.AllBrokersStartTimeoutSeconds
		*out = new(int)
		**out = **in
	}
	if in.TopicReassignmentTimeoutSeconds != nil {
		in, out := &in.TopicReassignmentTimeoutSeconds, &out.TopicReassignmentTimeoutSeconds
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Scaling.
func (in *Scaling) DeepCopy() *Scaling {
	if in == nil {
		return nil
	}
	out := new(Scaling)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretPaths) DeepCopyInto(out *SecretPaths) {
	*out = *in
	if in.Kafka != nil {
		in, out := &in.Kafka, &out.Kafka
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Monitoring != nil {
		in, out := &in.Monitoring, &out.Monitoring
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.MirrorMaker != nil {
		in, out := &in.MirrorMaker, &out.MirrorMaker
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.MirrorMakerMonitoring != nil {
		in, out := &in.MirrorMakerMonitoring, &out.MirrorMakerMonitoring
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretPaths.
func (in *SecretPaths) DeepCopy() *SecretPaths {
	if in == nil {
		return nil
	}
	out := new(SecretPaths)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Ssl) DeepCopyInto(out *Ssl) {
	*out = *in
	if in.CipherSuites != nil {
		in, out := &in.CipherSuites, &out.CipherSuites
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Ssl.
func (in *Ssl) DeepCopy() *Ssl {
	if in == nil {
		return nil
	}
	out := new(Ssl)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StatusCondition) DeepCopyInto(out *StatusCondition) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StatusCondition.
func (in *StatusCondition) DeepCopy() *StatusCondition {
	if in == nil {
		return nil
	}
	out := new(StatusCondition)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Storage) DeepCopyInto(out *Storage) {
	*out = *in
	if in.ClassName != nil {
		in, out := &in.ClassName, &out.ClassName
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Volumes != nil {
		in, out := &in.Volumes, &out.Volumes
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Nodes != nil {
		in, out := &in.Nodes, &out.Nodes
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Storage.
func (in *Storage) DeepCopy() *Storage {
	if in == nil {
		return nil
	}
	out := new(Storage)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TopicsBackup) DeepCopyInto(out *TopicsBackup) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TopicsBackup.
func (in *TopicsBackup) DeepCopy() *TopicsBackup {
	if in == nil {
		return nil
	}
	out := new(TopicsBackup)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VaultSecretManagement) DeepCopyInto(out *VaultSecretManagement) {
	*out = *in
	in.SecretPaths.DeepCopyInto(&out.SecretPaths)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VaultSecretManagement.
func (in *VaultSecretManagement) DeepCopy() *VaultSecretManagement {
	if in == nil {
		return nil
	}
	out := new(VaultSecretManagement)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VaultSecretManagementStatus) DeepCopyInto(out *VaultSecretManagementStatus) {
	*out = *in
	if in.SecretVersions != nil {
		in, out := &in.SecretVersions, &out.SecretVersions
		*out = make(map[string]int64, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VaultSecretManagementStatus.
func (in *VaultSecretManagementStatus) DeepCopy() *VaultSecretManagementStatus {
	if in == nil {
		return nil
	}
	out := new(VaultSecretManagementStatus)
	in.DeepCopyInto(out)
	return out
}
